!TRP_LIC Copyright 1994-2014 CNRS, Meteo-France and Universite Paul Sabatier
!TRP_LIC This is part of the CTRIP software governed by the CeCILL-C licence
!TRP_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!TRP_LIC for details. version 1.
!     #########
      SUBROUTINE PREP_TRIP_RUN (TP, TPG, TPLK, &
                                KYEAR,KMONTH,KDAY,PTIME,KLON,KLAT)
!     ####################
!
!!****  *PREP_TRIP_RUN*
!!
!!    PURPOSE
!!    -------
!
!     Prepare TRIP variables and parameters.
!
!!**  METHOD
!!    ------
!
!     Direct calculation
!
!!    EXTERNAL
!!    --------
!
!     None
!!
!!    IMPLICIT ARGUMENTS
!!    ------------------
!!
!!
!!    REFERENCE
!!    ---------
!!
!!    AUTHOR
!!    ------
!!      B. Decharme     (Meteo-France)
!!
!!    MODIFICATIONS
!!    -------------
!!      Original    27/05/08
!!      09/16   B. Decharme  limit wtd to -1000m
!!      11/19   T. Guinaldo  lakes added
!!      S. Munier   03/2020  CTRIP-12D and parallelization
!
!-------------------------------------------------------------------------------
!
!*       0.     DECLARATIONS
!               ------------
!
!
USE MODD_TRIP,      ONLY : TRIP_t
USE MODD_TRIP_GRID, ONLY : TRIP_GRID_t
USE MODD_TRIP_LAKE, ONLY : TRIP_LAKE_t
!
USE MODN_TRIP, ONLY : CGROUNDW, CVIT, LFLOOD,  &
                      XCVEL, XRATMED, XTSTEP,  &
                      LGWSUBF, XGWSUBD, LCALCRIVLEN, &
                      CLAKE, LBACKWATER, XBANKSLOPE

USE MODN_TRIP_PREP, ONLY : XTAUG_UNIF, LGWEQ, LREAD_FLOOD, &
                           XTAUG_UP, XTAUG_DOWN
!
USE MODD_TRIP_PAR
USE MODD_TRIP_LISTING, ONLY : NLISTING
!
USE MODE_TRIP_INIT
USE MODE_RW_TRIP
!
USE MODI_ABORT_TRIP
USE MODI_GET_TRIP_GRID_CONF
USE MODI_INIT_PARAM_TRIP
USE MODI_INIT_RESTART_TRIP
USE MODI_GET_LONLAT_TRIP
USE MODI_GET_LAKE_NUM
!
USE MODI_GWF
!
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
USE PARKIND1  ,ONLY : JPRB
!
IMPLICIT NONE
!
!-------------------------------------------------------------------------------
!
!*      0.1    declarations of arguments
!
!
TYPE(TRIP_t),      INTENT(INOUT) :: TP
TYPE(TRIP_GRID_t), INTENT(INOUT) :: TPG
TYPE(TRIP_LAKE_t), INTENT(INOUT) :: TPLK
!
INTEGER,          INTENT(IN) :: KYEAR   !date UTC
INTEGER,          INTENT(IN) :: KMONTH  !date UTC
INTEGER,          INTENT(IN) :: KDAY    !date UTC
REAL,             INTENT(IN) :: PTIME   !date UTC
INTEGER,          INTENT(OUT):: KLON    ! number of points in longitude
INTEGER,          INTENT(OUT):: KLAT    ! number of points in latitude
!
!-------------------------------------------------------------------------------
!
!*      0.2    declarations of local variables
!
LOGICAL,           PARAMETER         :: LDOUBLE         =.TRUE.
!
REAL,              PARAMETER         :: ZMINCELL        = 3.0
!
CHARACTER(LEN=20), PARAMETER         :: YFILE_PARAM_1D  ='TRIP_PGD_1D.nc'
CHARACTER(LEN=20), PARAMETER         :: YFILE_PARAM_HD  ='TRIP_PGD_HD.nc'
CHARACTER(LEN=20), PARAMETER         :: YFILE_PARAM_12  ='TRIP_PGD_12D.nc'
CHARACTER(LEN=20), PARAMETER         :: YFILE_INIT_1D   ='TRIP_INIT_1D.nc'
CHARACTER(LEN=20), PARAMETER         :: YFILE_INIT_HD   ='TRIP_INIT_HD.nc'
CHARACTER(LEN=20), PARAMETER         :: YFILE_INIT_12   ='TRIP_INIT_12D.nc'
!
CHARACTER(LEN=20), PARAMETER         :: YFILE_PARAM     ='TRIP_PARAM.nc'
CHARACTER(LEN=20), PARAMETER         :: YFILE_PREP      ='TRIP_PREP.nc'
!
CHARACTER(LEN=20)                    :: YFILE_READ
CHARACTER(LEN=20)                    :: YFILE_READ_INIT
!
CHARACTER(LEN=20), PARAMETER         :: YFILE_FLOOD_1D  ='TRIP_SGFLOOD_1D.nc'
CHARACTER(LEN=20), PARAMETER         :: YFILE_FLOOD_HD  ='TRIP_SGFLOOD_HD.nc'
CHARACTER(LEN=20), PARAMETER         :: YFILE_FLOOD_12  ='TRIP_SGFLOOD_12D.nc'
CHARACTER(LEN=20)                    :: YFILE_FLOOD_READ
!
CHARACTER(LEN=20), PARAMETER         :: YFILE_GW_HD     ='TRIP_SGAQUI_HD.nc'
CHARACTER(LEN=20), PARAMETER         :: YFILE_GW_12D    ='TRIP_SGAQUI_12D.nc'
CHARACTER(LEN=20)                    :: YFILE_GW_READ
CHARACTER(LEN=20), PARAMETER         :: YFILE_GW_FRC_HD ='GWEQ_HD_FRC.nc'
!
CHARACTER(LEN=20)                    :: YVAR
!
REAL, DIMENSION(:),ALLOCATABLE       :: ZLON
REAL, DIMENSION(:),ALLOCATABLE       :: ZLAT
!
REAL,DIMENSION(:,:),ALLOCATABLE      :: ZGRCN
REAL,DIMENSION(:,:),ALLOCATABLE      :: ZSEQ
REAL,DIMENSION(:,:),ALLOCATABLE      :: ZFRACAREA
REAL,DIMENSION(:,:),ALLOCATABLE      :: ZNUM_BAS
REAL,DIMENSION(:,:),ALLOCATABLE      :: ZDR_AREA
REAL,DIMENSION(:,:),ALLOCATABLE      :: ZREAD
REAL,DIMENSION(:,:),ALLOCATABLE      :: ZWORK
REAL,DIMENSION(:,:),ALLOCATABLE      :: ZGREEN_ANT
REAL,DIMENSION(:,:),ALLOCATABLE      :: ZHSTREAM
REAL,DIMENSION(:,:),ALLOCATABLE      :: ZDRAIN
REAL,DIMENSION(:,:),ALLOCATABLE      :: ZHG_OLD
!
INTEGER,DIMENSION(:),   ALLOCATABLE  :: ILAKE_ID_G
INTEGER,DIMENSION(:),   ALLOCATABLE  :: ILAKE_ID_L
REAL,   DIMENSION(:,:), ALLOCATABLE  :: ZLAKE_ID_G
LOGICAL,DIMENSION(:),   ALLOCATABLE  :: LMASK_LAKE
!
REAL,DIMENSION(:),    ALLOCATABLE    :: ZREAD1D
REAL,DIMENSION(:,:,:),ALLOCATABLE    :: ZREAD3D
!
INTEGER,DIMENSION(:,:),ALLOCATABLE   :: IGRCN
INTEGER,DIMENSION(:,:),ALLOCATABLE   :: INEXTX
INTEGER,DIMENSION(:,:),ALLOCATABLE   :: INEXTY
!
INTEGER,DIMENSION(:), ALLOCATABLE    :: INCELL_BAS
!
REAL    :: ZLONMIN   ! minimum longitude (degrees)
REAL    :: ZLONMAX   ! maximum longitude (degrees)
REAL    :: ZLATMIN   ! minimum latitude  (degrees)
REAL    :: ZLATMAX   ! maximum latitude  (degrees)
REAL    :: ZGRID_RES ! 1° or 0.5° or 0.083333° (1/12°) resolution
REAL    :: ZSEQMAX
!
INTEGER :: ILON, ILAT, ILAKE_NUM, ILAKE_NUM_G
INTEGER :: ILON_G, ILON_DEB, ILON_END
INTEGER :: ILAT_G, ILAT_DEB, ILAT_END
!
INTEGER :: IWORK, IFLOOD, INI, ILATF
INTEGER :: JLON, JLAT, JBAS, JITER, JLAKE
!
LOGICAL :: LMASKLON, LMASKLAT, LWORK
!
!-------------------------------------------------------------------------------
!Output attribut for netcdf diag file
!-------------------------------------------------------------------------------
!
CHARACTER(LEN=50) :: YTITLE,YTIMEUNIT
!                    YTITLE    = Title of each output file
!                    YTIMEUNIT = Time unit in each output file if present
!
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
!-------------------------------------------------------------------------------
!Initilyse TRIP
!-------------------------------------------------------------------------------
!
IF (LHOOK) CALL DR_HOOK('PREP_TRIP_RUN',0,ZHOOK_HANDLE)
!
WRITE(NLISTING,*)''
WRITE(NLISTING,*)'        PREP TRIP            '
WRITE(NLISTING,*)''
!
!-------------------------------------------------------------------------------
!
IF(LFLOOD)THEN
  IF(CGROUNDW=='DEF') &
      WRITE(NLISTING,*)'! Attention, you use the flooding scheme without groundwater scheme !!!'
  IF(CVIT /= 'VAR')THEN
    WRITE(NLISTING,*)'! You cannot use the flooding scheme without the variable velocity scheme !!!'
    CALL ABORT_TRIP('PREP_TRIP_RUN: You cannot use the flooding scheme without the variable velocity scheme')
  ENDIF
ENDIF
!
IF(CGROUNDW=='CST')THEN
  IF(XTAUG_UNIF<1.0.OR.XTAUG_UNIF>365.0)THEN
    WRITE(NLISTING,*)'! Constant transfert time value XTAUG_UNIF must be at least 1 day or inferior to 365 days !!!'
    CALL ABORT_TRIP('PREP_TRIP_RUN: Constant transfert time value must be at least 1 day or inferior to 365 days')
  ENDIF
ENDIF
!
IF(CGROUNDW=='DIF')THEN
  IF(CVIT /= 'VAR')THEN
    WRITE(NLISTING,*)'! You cannot use the groundwater scheme without the variable velocity scheme !!!'
    CALL ABORT_TRIP('PREP_TRIP_RUN: You cannot use the groundwater scheme without the variable velocity scheme')
  ENDIF
  IF(XTAUG_UP<1.0)THEN
    WRITE(NLISTING,*)'! Upstream transfert time value XTAUG_UP must be at least 1 day !!!'
    CALL ABORT_TRIP('PREP_TRIP_RUN: Upstream transfert time value must be at least 1 day')
  ENDIF
  IF(XTAUG_DOWN>365.0)THEN
    WRITE(NLISTING,*)'! Downstream transfert time value XTAUG_DOWN must be lower than 365 days !!!'
    CALL ABORT_TRIP('PREP_TRIP_RUN: Downstream transfert time value must be lower than 365 days')
  ENDIF
ENDIF
!
IF(LGWSUBF.AND.XGWSUBD>30.)THEN
     WRITE(NLISTING,*)'!! XGWSUBD too large (must be <=30), check your namelist  !!!'
     CALL ABORT_TRIP('PREP_TRIP_RUN: XGWSUBD too large (must be <=30), check your namelist !!!')
ENDIF
!
!-------------------------------------------------------------------------------
! * Read TRIP grid configuration
!-------------------------------------------------------------------------------
!
CALL GET_TRIP_GRID_CONF(TPG, &
                        ZLONMIN,ZLONMAX,ZLATMIN,ZLATMAX,ZGRID_RES,ILON,ILAT)
KLON=ILON
KLAT=ILAT
!
ALLOCATE(ZLON(ILON))
ALLOCATE(ZLAT(ILAT))
ZLON(:)=XUNDEF
ZLAT(:)=XUNDEF
!
CALL GET_LONLAT_TRIP(TPG, &
                     KLON,KLAT,ZLON,ZLAT)
!
IF(ZGRID_RES==1.0)THEN
!
  WRITE(NLISTING,*)'! 1° by 1° TRIP run !!!'
!
  ILON_G = 360
  ILAT_G = 180
  ILATF  = 31
  YFILE_READ = YFILE_PARAM_1D
  YFILE_READ_INIT = YFILE_INIT_1D
  YFILE_FLOOD_READ = YFILE_FLOOD_1D
!
ELSEIF(ZGRID_RES==0.5)THEN
!
  WRITE(NLISTING,*)'! 0.5° by 0.5° TRIP run !!!'
!
  ILON_G = 720
  ILAT_G = 360
  ILATF  = 61
  YFILE_READ = YFILE_PARAM_HD
  YFILE_READ_INIT = YFILE_INIT_HD
  YFILE_GW_READ = YFILE_GW_HD
  YFILE_FLOOD_READ = YFILE_FLOOD_HD
!
ELSEIF(ZGRID_RES<0.09)THEN
!
  WRITE(NLISTING,*)'! 1/12° by 1/12° TRIP run !!!'
!
  ILON_G = 4320
  ILAT_G = 2160
  !ILATF  = 361
  ILATF  = 1
  YFILE_READ = YFILE_PARAM_12
  YFILE_READ_INIT = YFILE_INIT_12
  YFILE_GW_READ = YFILE_GW_12D
  YFILE_FLOOD_READ = YFILE_FLOOD_12
!
ELSE
!
  WRITE(NLISTING,*)'! The resolution of the TRIP run is not good !!!'
  WRITE(NLISTING,*)'! Should be 1° or 0.5° or 1/12° !!!'
  CALL ABORT_TRIP('PREP_TRIP_RUN: resolution of the TRIP run is not good')
!
ENDIF
!
IF(CGROUNDW=='DIF'.AND.ZGRID_RES>0.5)THEN
  WRITE(NLISTING,*)'! You cannot use the groundwater scheme with another resolution than 0.5 or 1/12 !!!'
  CALL ABORT_TRIP('PREP_TRIP_RUN: You cannot use the groundwater scheme with another resolution than 0.5 or 1/12')
ENDIF
!
IF(LGWEQ.AND.ZGRID_RES/=0.5)THEN
  WRITE(NLISTING,*)'! You cannot use groundwater equilibrium with another resolution than 0.5  !!!'
  CALL ABORT_TRIP('PREP_TRIP_RUN: You cannot use groundwater equilibrium with another resolution than 0.5')
ENDIF
!
IF(CLAKE=='MLK' .AND. ZGRID_RES>0.09)THEN
  WRITE(NLISTING,*)'! You can not use the lake model with another resolution than 1/12 !!!'
ENDIF
!
LMASKLON=.FALSE.
IF(ZLONMIN/=-180..OR.ZLONMAX/=180.)LMASKLON=.TRUE.
!
LMASKLAT=.FALSE.
IF(ZLATMIN/=-180..OR.ZLATMAX/=180.)LMASKLAT=.TRUE.
!
ILAKE_NUM = 0
IF(CLAKE=='MLK') THEN
  CALL GET_LAKE_NUM(NLISTING,YFILE_READ,ILON_G,ILAT_G,ZLONMIN,ZLONMAX,ZLATMIN,ZLATMAX,ILAKE_NUM,ILAKE_NUM_G)
ENDIF
!
!-------------------------------------------------------------------------------
!Allocate arguments
!-------------------------------------------------------------------------------
!
ALLOCATE(TPG%GMASK    (ILON,ILAT))
ALLOCATE(TPG%GMASK_VEL(ILON,ILAT))
ALLOCATE(TPG%GMASK_GW (ILON,ILAT))
ALLOCATE(TPG%GMASK_FLD(ILON,ILAT))
ALLOCATE(TPG%GMASK_GRE(ILON,ILAT))
ALLOCATE(TPG%GMASK_ANT(ILON,ILAT))
ALLOCATE(TPG%GMASK_LAKE_IN(ILON,ILAT))
ALLOCATE(TPG%GMASK_LAKE_NW(ILON,ILAT))
TPG%GMASK    (:,:) = .FALSE.
TPG%GMASK_VEL(:,:) = .FALSE.
TPG%GMASK_GW (:,:) = .FALSE.
TPG%GMASK_FLD(:,:) = .FALSE.
TPG%GMASK_GRE(:,:) = .FALSE.
TPG%GMASK_ANT(:,:) = .FALSE.
TPG%GMASK_LAKE_IN(:,:) = .FALSE.
TPG%GMASK_LAKE_NW(:,:) = .FALSE.
!
ALLOCATE(TPG%XAREA (ILON,ILAT))
ALLOCATE(TPG%XLEN  (ILON,ILAT))
ALLOCATE(TPG%NGRCN (ILON,ILAT))
ALLOCATE(TPG%NBASID(ILON,ILAT))
!
ALLOCATE(ZGRCN     (ILON,ILAT))
ALLOCATE(ZSEQ      (ILON,ILAT))
ALLOCATE(ZFRACAREA (ILON,ILAT))
ALLOCATE(ZNUM_BAS  (ILON,ILAT))
ALLOCATE(ZDR_AREA  (ILON,ILAT))
ALLOCATE(ZGREEN_ANT(ILON,ILAT))
!
ALLOCATE(TP%XSURF_STO(ILON,ILAT))
!
IF(CGROUNDW/='DEF')THEN
  ALLOCATE(TP%XTAUG      (ILON,ILAT))
ELSE
  ALLOCATE(TP%XTAUG      (0,0))
ENDIF
!
IF(CGROUNDW=='CST')THEN
  ALLOCATE(TP%XGROUND_STO(ILON,ILAT))
ELSE
  ALLOCATE(TP%XGROUND_STO(0,0))
ENDIF
!
IF(CGROUNDW=='DIF'.OR.LBACKWATER)THEN
  ALLOCATE(TP%XHGROUND   (ILON,ILAT))
  ALLOCATE(TP%XWEFF      (ILON,ILAT))
  ALLOCATE(TP%XTRANS     (ILON,ILAT))
  ALLOCATE(TP%XNUM_AQUI  (ILON,ILAT))
  ALLOCATE(TP%XTOPO_RIV  (ILON,ILAT))
ELSE
  ALLOCATE(TP%XHGROUND   (0,0))
  ALLOCATE(TP%XWEFF      (0,0))
  ALLOCATE(TP%XTRANS     (0,0))
  ALLOCATE(TP%XNUM_AQUI  (0,0))
  ALLOCATE(TP%XTOPO_RIV  (0,0))
ENDIF
!
IF(LFLOOD.OR.CGROUNDW=='DIF'.OR.XBANKSLOPE>0)THEN
  ALLOCATE(TP%XHC_BED    (ILON,ILAT))
ELSE
  ALLOCATE(TP%XHC_BED   (0,0))
ENDIF
!
IF(LFLOOD)THEN
  ALLOCATE(TP%XN_FLOOD    (ILON,ILAT))
  ALLOCATE(TP%XFLOOD_STO  (ILON,ILAT))
  ALLOCATE(TP%XHFLOOD     (ILON,ILAT))
  ALLOCATE(TP%XFFLOOD     (ILON,ILAT))
ELSE
  ALLOCATE(TP%XN_FLOOD  (0,0))
  ALLOCATE(TP%XFLOOD_STO(0,0))
  ALLOCATE(TP%XHFLOOD   (0,0))
  ALLOCATE(TP%XFFLOOD   (0,0))
ENDIF
!
IF(CVIT=='VAR')THEN
  ALLOCATE(TP%XSLOPEBED(ILON,ILAT))
  ALLOCATE(TP%XWIDTH   (ILON,ILAT))
  ALLOCATE(TP%XN       (ILON,ILAT))
ELSE
  ALLOCATE(TP%XSLOPEBED(0,0))
  ALLOCATE(TP%XWIDTH   (0,0))
  ALLOCATE(TP%XN       (0,0))
ENDIF
!
IF(CLAKE=='MLK')THEN
  TPLK%NLAKE_NUM = ILAKE_NUM
  ALLOCATE(TPLK%NLAKE_ID_IN(ILON,ILAT))
  ALLOCATE(TPLK%NLAKE_ID_NW(ILON,ILAT))
  ALLOCATE(TPLK%XFRAC_LAKE(ILON,ILAT))
  ALLOCATE(TPLK%XLAKE_A(ILAKE_NUM))
  ALLOCATE(TPLK%XWEIR_Z(ILAKE_NUM))
  ALLOCATE(TPLK%XWEIR_W(ILAKE_NUM))
  !ALLOCATE(TPLK%XZ_EQ(ILAKE_NUM))
  !ALLOCATE(TPLK%XNSIGMA(ILAKE_NUM))
  ALLOCATE(TPLK%XLAKE_STO(ILAKE_NUM))
ELSE
  TPLK%NLAKE_NUM = 0
  ALLOCATE(TPLK%NLAKE_ID_IN(0,0))
  ALLOCATE(TPLK%NLAKE_ID_NW(0,0))
  ALLOCATE(TPLK%XFRAC_LAKE(0,0))
  ALLOCATE(TPLK%XLAKE_A(0))
  ALLOCATE(TPLK%XWEIR_Z(0))
  ALLOCATE(TPLK%XWEIR_W(0))
  !ALLOCATE(TPLK%XZ_EQ(0))
  !ALLOCATE(TPLK%XNSIGMA(0))
  ALLOCATE(TPLK%XLAKE_STO(0))
ENDIF
!
!-------------------------------------------------------------------------------
! * Create param and init file
!-------------------------------------------------------------------------------
!
YTITLE    = 'TRIP parameters for a run'
YTIMEUNIT = '-'
CALL INIT_PARAM_TRIP(TPG, &
                     NLISTING,YFILE_PARAM,ILON,ILAT,ILAKE_NUM,YTITLE,YTIMEUNIT)
!
YTITLE    = 'TRIP prep historical variable'
YTIMEUNIT = '-'
CALL INIT_RESTART_TRIP(TPG, &
                       NLISTING,YFILE_PREP,ILON,ILAT,ILAKE_NUM,YTITLE,YTIMEUNIT,.FALSE.)
!
!-------------------------------------------------------------------------------
! * Compute the mask of the run
!-------------------------------------------------------------------------------
!
ILON_DEB = INT(ZLONMIN/ZGRID_RES) + ILON_G/2 + 1
ILON_END = INT(ZLONMAX/ZGRID_RES) + ILON_G/2
ILAT_DEB = INT(ZLATMIN/ZGRID_RES) + ILAT_G/2 + 1
ILAT_END = INT(ZLATMAX/ZGRID_RES) + ILAT_G/2
!
ALLOCATE(IGRCN (ILON_G,ILAT_G))
ALLOCATE(INEXTX(ILON_G,ILAT_G))
ALLOCATE(INEXTY(ILON_G,ILAT_G))
ALLOCATE(ZWORK (ILON_G,ILAT_G))
!
ALLOCATE(ZREAD(ILON_G,ILAT_G))
!
!-------------------------------------------------------------------------------
! * Compute and Read TRIP parameter
!-------------------------------------------------------------------------------
!
IGRCN =0
INEXTX=0
INEXTY=0
!
! * Basin ID
!
YVAR ='NUM_BAS'
CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
ZNUM_BAS(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
WHERE(ZNUM_BAS>=XUNDEF-1.0)ZNUM_BAS=0.0
TPG%NBASID(:,:)=INT(ZNUM_BAS(:,:))
!
TPG%NBASMIN = MINVAL(TPG%NBASID(:,:),TPG%NBASID(:,:)>0)
TPG%NBASMAX = MAXVAL(TPG%NBASID(:,:),TPG%NBASID(:,:)>0)
!
! * Drainage Area
!
YVAR ='DR_AREA'
CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
ZDR_AREA(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
! * Flow direction
!
YVAR ='FLOWDIR'
CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
ZGRCN(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
WHERE(ZREAD(:,:)==XUNDEF)ZREAD(:,:)=0.0
!
! * River reach length
!
IF(ZGRID_RES > 0.09.OR.LCALCRIVLEN)THEN
!
! * Set the distance between grids with the meandering ratio
!
  IGRCN = INT(ZREAD)
  CALL SETNEXT(ILON_G,ILAT_G,IGRCN,INEXTX,INEXTY)
!
  CALL SETLEN(ILON_G,ILAT_G,IGRCN,INEXTX,INEXTY,XRATMED,ZWORK)
  TPG%XLEN(:,:) = ZWORK(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
ELSE
!
! * River reach length read from TRIP_PARAM.nc
!
  YVAR ='RIVLEN'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  TPG%XLEN(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
! Meadering ratio is forced to one
  XRATMED = 1.0
!
ENDIF
!
! * Set area size
!
IF(ZGRID_RES==0.5)THEN
  YVAR ='FRACAREA'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  ZFRACAREA(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!ELSEIF(ZGRID_RES<0.09)THEN
!  YVAR ='FRACAREA'
!  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
!  ZFRACAREA(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
ELSE
  ZFRACAREA(:,:) = 1.0
ENDIF
!
CALL SETAREA(ILAT,ZLATMIN,ZGRID_RES,TPG%XAREA)
!
TPG%XLEN (:,:) = TPG%XLEN (:,:) * ZFRACAREA(:,:)
TPG%XAREA(:,:) = TPG%XAREA(:,:) * ZFRACAREA(:,:)
!
DEALLOCATE(IGRCN )
DEALLOCATE(INEXTX)
DEALLOCATE(INEXTY)
DEALLOCATE(ZWORK )
DEALLOCATE(ZFRACAREA)
!
! * Domain test
!
ALLOCATE(INEXTX(ILON,ILAT))
ALLOCATE(INEXTY(ILON,ILAT))
!
WHERE(ZGRCN(:,:)<XUNDEF-1.0)
  TPG%NGRCN(:,:)=INT(ZGRCN(:,:))
  TPG%GMASK(:,:)=.TRUE.
ELSEWHERE
  TPG%NGRCN(:,:)=0
  TPG%GMASK(:,:)=.FALSE.
ENDWHERE
!
CALL SETNEXT(ILON,ILAT,TPG%NGRCN,INEXTX,INEXTY,LMASKLON,LMASKLAT)
!
! * Store some param
!
YVAR ='FLOWDIR'
ZGRCN(:,:)=REAL(TPG%NGRCN(:,:))
CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,ZGRCN)
YVAR ='RIVLEN'
CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,TPG%XLEN,ODOUBLE=LDOUBLE)
YVAR ='NUM_BAS'
CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,ZNUM_BAS)
YVAR ='DR_AREA'
CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,ZDR_AREA,ODOUBLE=LDOUBLE)
YVAR ='CELL_AREA'
CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,TPG%XAREA,ODOUBLE=LDOUBLE)
!
DEALLOCATE(ZDR_AREA)
DEALLOCATE(ZNUM_BAS)
!
! * River sequence values read
!
YVAR ='RIVSEQ'
CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
ZSEQ(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,ZSEQ)
!
! * Initial river storage
!
YVAR ='SURF_STO'
CALL READ_TRIP(NLISTING,YFILE_READ_INIT,YVAR,ZREAD)
TP%XSURF_STO(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
CALL WRITE_TRIP(NLISTING,YFILE_PREP,YVAR,TPG%GMASK,TP%XSURF_STO,ODOUBLE=LDOUBLE)
!
! * Greenland and Antarctic masks
!
YVAR ='GREEN_ANT'
IF(ZGRID_RES > 0.09)THEN
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
ELSE
  ZREAD(:,:)=0.0
ENDIF
ZGREEN_ANT(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,ZGREEN_ANT)
DO JLAT=1,ILAT
  DO JLON=1,ILON
    IF(ZGREEN_ANT(JLON,JLAT)==2.0)THEN
      TPG%GMASK_ANT(JLON,JLAT)=.TRUE.
    ELSEIF(ZGREEN_ANT(JLON,JLAT)==1.0)THEN
      TPG%GMASK_GRE(JLON,JLAT)=.TRUE.
    ENDIF
  ENDDO
ENDDO
!
DEALLOCATE(ZLON)
DEALLOCATE(ZLAT)
DEALLOCATE(ZGREEN_ANT)
!
IF(LBACKWATER.OR.CGROUNDW=='DIF')THEN
!
  YVAR ='TOPO_RIV'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  TP%XTOPO_RIV(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,TP%XTOPO_RIV)
!
ENDIF
!
! * Variable velocity scheme parameters
!
IF(CVIT == 'VAR')THEN
!
  YVAR ='N_RIV'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  TP%XN(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,TP%XN)
!
  YVAR ='WIDTHRIV'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  TP%XWIDTH(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,TP%XWIDTH)
!
  YVAR ='SLOPERIV'
  IF(.FALSE.)THEN !LBACKWATER.AND.LCALCRIVLEN)THEN
    TP%XSLOPEBED(:,:) = XUNDEF
    DO JLAT=1,ILAT
      DO JLON=1,ILON
        IF(TPG%NGRCN(JLON,JLAT)>0.AND.TPG%NGRCN(JLON,JLAT)<9)THEN
          TP%XSLOPEBED(JLON,JLAT) = &
            (TP%XTOPO_RIV(JLON,JLAT)-TP%XTOPO_RIV(INEXTX(JLON,JLAT),INEXTY(JLON,JLAT)))/TPG%XLEN(JLON,JLAT)*XRATMED
        ENDIF
      ENDDO
    ENDDO
  ELSE
    CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
    TP%XSLOPEBED(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
  ENDIF
  WHERE(TP%XSLOPEBED(:,:)<XUNDEF-1.0)
    TP%XSLOPEBED(:,:) = MAX(1.E-5,TP%XSLOPEBED(:,:)/XRATMED)
  ENDWHERE
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,TP%XSLOPEBED,ODOUBLE=LDOUBLE)
!
  TPG%GMASK_VEL(:,:)=TPG%GMASK(:,:)
  WHERE(TP%XWIDTH(:,:)>=XUNDEF-1.0)
    TPG%GMASK_VEL(:,:)=.FALSE.
  ENDWHERE
!
ENDIF
!
DEALLOCATE(INEXTX)
DEALLOCATE(INEXTY)
!
! * River depth
!
IF (LFLOOD.OR.CGROUNDW=='DIF'.OR.XBANKSLOPE>0) THEN
!
  YVAR ='RIVDEPTH'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  TP%XHC_BED(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
  WHERE(TP%XHC_BED(:,:)==0.0)
        TP%XHC_BED(:,:)=XUNDEF
  ENDWHERE
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,TP%XHC_BED)
!
ENDIF
!
! * Groundwater parameters
!
IF(CGROUNDW=='CST')THEN
!
  TPG%GMASK_GW(:,:)=TPG%GMASK(:,:)
!
  YVAR ='GROUND_STO'
  CALL READ_TRIP(NLISTING,YFILE_READ_INIT,YVAR,ZREAD)
  TP%XGROUND_STO(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
  TP%XTAUG(:,:)=XTAUG_UNIF
  WHERE(TPG%GMASK_ANT(:,:).OR.TPG%GMASK_GRE(:,:))
        TP%XTAUG      (:,:)=XUNDEF
        TPG%GMASK_GW  (:,:)=.FALSE.
        TP%XGROUND_STO(:,:)=0.0
  ENDWHERE
!
  YVAR ='TAUG'
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_GW,TP%XTAUG)
!
  YVAR ='GROUND_STO'
  CALL WRITE_TRIP(NLISTING,YFILE_PREP,YVAR,TPG%GMASK_GW,TP%XGROUND_STO,ODOUBLE=LDOUBLE)
!
ELSEIF(CGROUNDW=='DIF')THEN
!
  YVAR ='NUM_AQUI'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  TP%XNUM_AQUI(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK,TP%XNUM_AQUI)
!
  YVAR ='WEFF'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  TP%XWEFF(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
  TPG%GMASK_GW(:,:)=TPG%GMASK(:,:)
  WHERE(TP%XWEFF(:,:)>=XUNDEF-1.0)
        TPG%GMASK_GW(:,:)=.FALSE.
  ENDWHERE
!
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_GW,TP%XWEFF)
!
  YVAR ='TRANS'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  TP%XTRANS(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_GW,TP%XTRANS)
!
  IF(ZGRID_RES > 0.09)THEN
    ZSEQMAX=5.0
  ELSE
    ZSEQMAX=10.0
  ENDIF
  TP%XTAUG(:,:)=XTAUG_DOWN+(XTAUG_UP-XTAUG_DOWN)*(ZSEQMAX-MIN(ZSEQMAX,ZSEQ(:,:)))/(ZSEQMAX-1.0)
!
  YVAR ='TAUG'
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_GW,TP%XTAUG)
!
  ALLOCATE(ZREAD3D(ILON_G,ILAT_G,NDIMTAB))
  ZREAD3D(:,:,:)= XUNDEF
!
  ALLOCATE(TP%XTABGW_F (ILON,ILAT,NDIMTAB))
  ALLOCATE(TP%XTABGW_H (ILON,ILAT,NDIMTAB))
!
  TP%XTABGW_F(:,:,:)= XUNDEF
  TP%XTABGW_H(:,:,:)= XUNDEF
!
  YVAR ='TABGW_F'
  CALL READ_TRIP(NLISTING,YFILE_GW_READ,YVAR,ZREAD3D(:,ILATF:ILAT_G,:))
  TP%XTABGW_F(:,:,:) = ZREAD3D(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END,:)
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_GW,TP%XTABGW_F)
!
  YVAR ='TABGW_H'
  CALL READ_TRIP(NLISTING,YFILE_GW_READ,YVAR,ZREAD3D(:,ILATF:ILAT_G,:))
  TP%XTABGW_H(:,:,:) = ZREAD3D(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END,:)
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_GW,TP%XTABGW_H)
!
  DEALLOCATE(ZREAD3D)
!
! Groundwater init from file
!
  YVAR ='HGROUND'
  CALL READ_TRIP(NLISTING,YFILE_READ_INIT,YVAR,ZREAD)
  TP%XHGROUND(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
  WHERE(TPG%GMASK_GW(:,:))
        TP%XHGROUND(:,:) = MAX(TP%XHGROUND(:,:),TP%XTOPO_RIV(:,:)-XGWDZMAX)
  ENDWHERE
!
  IF(LGWEQ)THEN
!
!   Groundwater equilibrium (appendix B in Vergnes thesis)
!
    ALLOCATE(ZHSTREAM(ILON,ILAT))
    ALLOCATE(ZDRAIN  (ILON,ILAT))
    ALLOCATE(ZHG_OLD (ILON,ILAT))
!
    LWORK         = .FALSE.
    ZHG_OLD (:,:) = XUNDEF
!
    YVAR ='HSTREAM'
    CALL READ_TRIP(NLISTING,YFILE_GW_FRC_HD,YVAR,ZREAD)
    ZHSTREAM(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
    ZHSTREAM(:,:) = MIN(TP%XHC_BED(:,:),ZHSTREAM(:,:))
!
    YVAR ='DRAIN'
    CALL READ_TRIP(NLISTING,YFILE_GW_FRC_HD,YVAR,ZREAD)
    ZDRAIN(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END) !kg/m2/s
    ZDRAIN(:,:) = MAX(0.0,ZDRAIN(:,:)) * TPG%XAREA(:,:)      !kg/s
!
    TP%XWEFF   (:,:) = 0.0
!
    DO JITER=1,2
      CALL GWF(TP, TPG, &
               KLON,KLAT,LWORK,XTSTEP,XTSTEP,ZDRAIN,ZHSTREAM,TP%XHGROUND,ZHG_OLD)
    ENDDO
!
    DEALLOCATE(ZHSTREAM)
    DEALLOCATE(ZDRAIN  )
    DEALLOCATE(ZHG_OLD )
!
  ENDIF
!
  YVAR ='HGROUND'
  CALL WRITE_TRIP(NLISTING,YFILE_PREP,YVAR,TPG%GMASK_GW,TP%XHGROUND,ODOUBLE=LDOUBLE)
!
ENDIF
!
! * Calculate floodplains parameters
!
IF(LFLOOD)THEN
!
  ALLOCATE(INCELL_BAS(TPG%NBASMAX))
!
  INCELL_BAS(:)=0
  DO JLAT=1,ILAT
    DO JLON=1,ILON
      JBAS=TPG%NBASID(JLON,JLAT)
      IF(JBAS>0)THEN
        INCELL_BAS(JBAS)=INCELL_BAS(JBAS)+1
      ENDIF
    ENDDO
  ENDDO
!
  YVAR ='NFLOOD'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  TP%XN_FLOOD(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
  ALLOCATE(ZREAD3D(ILON_G,ILAT_G,NDIMTAB))
  ZREAD3D(:,:,:)= XUNDEF
!
  ALLOCATE(TP%XTAB_F (ILON,ILAT,NDIMTAB))
  ALLOCATE(TP%XTAB_H (ILON,ILAT,NDIMTAB))
  ALLOCATE(TP%XTAB_VF(ILON,ILAT,NDIMTAB))
!
  TP%XTAB_F (:,:,:)= XUNDEF
  TP%XTAB_H (:,:,:)= XUNDEF
  TP%XTAB_VF(:,:,:)= XUNDEF
!
  YVAR ='TABF'
  CALL READ_TRIP(NLISTING,YFILE_FLOOD_READ,YVAR,ZREAD3D(:,ILATF:ILAT_G,:))
  TP%XTAB_F(:,:,:) = ZREAD3D(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END,:)
  YVAR ='TABH'
  CALL READ_TRIP(NLISTING,YFILE_FLOOD_READ,YVAR,ZREAD3D(:,ILATF:ILAT_G,:))
  TP%XTAB_H(:,:,:) = ZREAD3D(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END,:)
  YVAR ='TABVF'
  CALL READ_TRIP(NLISTING,YFILE_FLOOD_READ,YVAR,ZREAD3D(:,ILATF:ILAT_G,:))
  TP%XTAB_VF(:,:,:) = ZREAD3D(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END,:)
!
  DEALLOCATE(ZREAD3D)
!
  WHERE(TP%XHC_BED(:,:)==XUNDEF)
        TP%XN_FLOOD(:,:)=XUNDEF
  ENDWHERE
!
  WHERE(TP%XTAB_F(:,:,1)==XUNDEF)
        TP%XN_FLOOD(:,:)=XUNDEF
  ENDWHERE
!
  WHERE(TP%XTAB_H(:,:,1)==XUNDEF)
        TP%XN_FLOOD(:,:)=XUNDEF
  ENDWHERE
!
! No flood processes in very small basins
  LWORK=(ILAT*ILON>ZMINCELL)
  DO JLAT=1,ILAT
     DO JLON=1,ILON
        JBAS=TPG%NBASID(JLON,JLAT)
        IF(JBAS==0)CYCLE
        IF(LWORK.AND.INCELL_BAS(JBAS)<=ZMINCELL)THEN
           TP%XN_FLOOD(JLON,JLAT)=XUNDEF
        ENDIF
     ENDDO
  ENDDO
!
  TPG%GMASK_FLD(:,:)=TPG%GMASK_VEL(:,:)
  WHERE(TP%XN_FLOOD(:,:)==XUNDEF)
        TPG%GMASK_FLD(:,:)=.FALSE.
  ENDWHERE
!
  YVAR ='NFLOOD'
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_FLD,TP%XN_FLOOD)
!
  YVAR ='TABF'
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_FLD,TP%XTAB_F)
  YVAR ='TABH'
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_FLD,TP%XTAB_H)
  YVAR ='TABVF'
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_FLD,TP%XTAB_VF)
!
! Floodplains initial variables
!
  IF(LREAD_FLOOD)THEN
    YVAR ='FLOOD_STO'
    CALL READ_TRIP(NLISTING,YFILE_READ_INIT,YVAR,ZREAD)
    TP%XFLOOD_STO(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
    YVAR ='FFLOOD'
    CALL READ_TRIP(NLISTING,YFILE_READ_INIT,YVAR,ZREAD)
    TP%XFFLOOD(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
    YVAR ='HFLOOD'
    CALL READ_TRIP(NLISTING,YFILE_READ_INIT,YVAR,ZREAD)
    TP%XHFLOOD(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
  ELSE
    TP%XFLOOD_STO(:,:) = 0.0
    TP%XFFLOOD   (:,:) = 0.0
    TP%XHFLOOD   (:,:) = 0.0
  ENDIF
!
  YVAR ='FLOOD_STO'
  CALL WRITE_TRIP(NLISTING,YFILE_PREP,YVAR,TPG%GMASK,TP%XFLOOD_STO,ODOUBLE=LDOUBLE)
!
  YVAR ='FFLOOD'
  CALL WRITE_TRIP(NLISTING,YFILE_PREP,YVAR,TPG%GMASK,TP%XFFLOOD,ODOUBLE=LDOUBLE)
!
  YVAR ='HFLOOD'
  CALL WRITE_TRIP(NLISTING,YFILE_PREP,YVAR,TPG%GMASK,TP%XHFLOOD,ODOUBLE=LDOUBLE)
!
  DEALLOCATE(INCELL_BAS)
!
ENDIF
!
! * Calculate lake parameters
!
IF(CLAKE=='MLK')THEN
!
  ALLOCATE(ZLAKE_ID_G(ILON,ILAT))
!
  YVAR='LAKE_ID_IN'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  ZLAKE_ID_G(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
  WHERE(ZLAKE_ID_G>0.0.AND.ZLAKE_ID_G/=XUNDEF) TPG%GMASK_LAKE_IN(:,:) = .TRUE.
!
! Remapping of lake ids and definition of local lake ids
!
  ALLOCATE(ILAKE_ID_G(ILAKE_NUM_G))
  ALLOCATE(ILAKE_ID_L(ILAKE_NUM))
  ALLOCATE(ZWORK(ILON,ILAT))
  ALLOCATE(ZREAD1D(ILAKE_NUM_G))
  ALLOCATE(LMASK_LAKE(ILAKE_NUM))
!
  TPLK%NLAKE_ID_IN(:,:) = 0
  TPLK%NLAKE_ID_NW(:,:) = 0
  LMASK_LAKE(:) = .TRUE.
  ILAKE_ID_G(:) = 0
  JLAKE = 0
  DO JLAT = KLAT,1,-1
    DO JLON = 1,KLON
      IF(TPG%GMASK_LAKE_IN(JLON,JLAT))THEN
        IWORK = INT(ZLAKE_ID_G(JLON,JLAT))
        IF(ILAKE_ID_G(IWORK)==0)THEN
          JLAKE = JLAKE+1
          ILAKE_ID_G(IWORK) = JLAKE
          ILAKE_ID_L(JLAKE) = IWORK
        ENDIF
        TPLK%NLAKE_ID_IN(JLON,JLAT) = ILAKE_ID_G(IWORK)
      ENDIF
    ENDDO
  ENDDO
  IF(JLAKE/=ILAKE_NUM)THEN
    WRITE(NLISTING,*) 'Error with lake remapping'
    CALL ABORT_TRIP('PREP_TRIP_RUN: Error with lake remapping')
  ENDIF
!
  DO JLAT = KLAT,1,-1
    DO JLON = 1,KLON
      ZWORK(JLON,JLAT) = REAL(TPLK%NLAKE_ID_IN(JLON,JLAT))
    ENDDO
  ENDDO
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_LAKE_IN,ZWORK)
!
  YVAR='LAKE_ID_NW'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  ZLAKE_ID_G(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
  WHERE(ZLAKE_ID_G>0.0.AND.ZLAKE_ID_G/=XUNDEF) TPG%GMASK_LAKE_NW(:,:) = .TRUE.
!
  DO JLAT = 1,KLAT
    DO JLON = 1,KLON
      IF(TPG%GMASK_LAKE_NW(JLON,JLAT))THEN
        TPLK%NLAKE_ID_NW(JLON,JLAT) = ILAKE_ID_G(INT(ZLAKE_ID_G(JLON,JLAT)))
      ENDIF
    ENDDO
  ENDDO
!
  DO JLAT = 1,KLAT
    DO JLON = 1,KLON
      ZWORK(JLON,JLAT) = REAL(TPLK%NLAKE_ID_NW(JLON,JLAT))
    ENDDO
  ENDDO
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_LAKE_NW,ZWORK)
!
  YVAR='FRAC_LAKE'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD)
  TPLK%XFRAC_LAKE(:,:) = ZREAD(ILON_DEB:ILON_END,ILAT_DEB:ILAT_END)
!
  TPLK%XLAKE_A(:) = 0
  DO JLAT = 1,ILAT
    DO JLON = 1,ILON
      IF(TPG%GMASK_LAKE_IN(JLON,JLAT))THEN
        JLAKE = TPLK%NLAKE_ID_IN(JLON,JLAT)
        TPLK%XLAKE_A(JLAKE) = TPLK%XLAKE_A(JLAKE) + (TPG%XAREA(JLON,JLAT)*TPLK%XFRAC_LAKE(JLON,JLAT))
      ENDIF
    ENDDO
  ENDDO
!
  WHERE(TPG%GMASK_LAKE_NW) TPLK%XFRAC_LAKE(:,:) = 1.
!
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,TPG%GMASK_LAKE_IN,TPLK%XFRAC_LAKE)
!
  YVAR='LAKE_A'
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,LMASK_LAKE,TPLK%XLAKE_A)
!
  YVAR='WEIR_Z'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD1D)
  DO JLAKE = 1,ILAKE_NUM
    TPLK%XWEIR_Z(JLAKE) = ZREAD1D(ILAKE_ID_L(JLAKE))
  ENDDO
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,LMASK_LAKE,TPLK%XWEIR_Z)
!
  YVAR='WEIR_W'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD1D)
  DO JLAKE = 1,ILAKE_NUM
    TPLK%XWEIR_W(JLAKE) = ZREAD1D(ILAKE_ID_L(JLAKE))
  ENDDO
  CALL WRITE_TRIP(NLISTING,YFILE_PARAM,YVAR,LMASK_LAKE,TPLK%XWEIR_W)
!
  YVAR='LAKE_Z'
  CALL READ_TRIP(NLISTING,YFILE_READ,YVAR,ZREAD1D)
  DO JLAKE = 1,ILAKE_NUM
!     TPLK%XZ_EQ(JLAKE) = ZREAD1D(ILAKE_ID_L(JLAKE))
    TPLK%XLAKE_STO(JLAKE) = ZREAD1D(ILAKE_ID_L(JLAKE))*TPLK%XLAKE_A(JLAKE)*XRHOLW
  ENDDO
!
  YVAR='LAKE_STO'
!   CALL READ_TRIP(NLISTING,YFILE_READ_INIT,YVAR,ZREAD1D)
!   DO JLAKE = 1,ILAKE_NUM
!     TPLK%XLAKE_STO(JLAKE) = ZREAD1D(ILAKE_ID_L(JLAKE))/10
!   ENDDO
  CALL WRITE_TRIP(NLISTING,YFILE_PREP,YVAR,LMASK_LAKE,TPLK%XLAKE_STO)
!
  DEALLOCATE(ILAKE_ID_G)
  DEALLOCATE(ILAKE_ID_L)
  DEALLOCATE(ZWORK)
  DEALLOCATE(ZREAD1D)
  DEALLOCATE(ZLAKE_ID_G)
!
ENDIF
!
DEALLOCATE(ZREAD)
!
!-------------------------------------------------------------------------------
! * Store current start date
!-------------------------------------------------------------------------------
!
CALL WRITE_TRIP_DATE(NLISTING,YFILE_PREP,KYEAR,KMONTH,KDAY,PTIME)
!
!-------------------------------------------------------------------------------
! * END
!-------------------------------------------------------------------------------
!
WRITE(NLISTING,*)''
WRITE(NLISTING,*)'        END PREP TRIP            '
WRITE(NLISTING,*)''
IF (LHOOK) CALL DR_HOOK('PREP_TRIP_RUN',1,ZHOOK_HANDLE)
!
!-------------------------------------------------------------------------------
END SUBROUTINE PREP_TRIP_RUN
